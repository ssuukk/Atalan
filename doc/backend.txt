***********************
ATALAN Compiler Backend
***********************

Atalan compiler provides configurable backend, that can be easily enhanced (or 
maybe even used to produce code for other processors).

Compilation is done in four phases:

- parsing
- translation
- optimization
- emit

=======
Parsing
=======

Parser parses code and produces program written using compiler instructions.
Compiler instructions are three address instructions, like

::::::::::::::::::::::::
let P, 10
let Q, 15
add R, P, Q
::::::::::::::::::::::::

===========
Translation
===========

Code generated by parser it then translated for specific processor.
This is done using rules defined in Atalan processor file.
Resulting code consist of processor instructions, which are equivalent to
some processor instructions.

::::::::::::::::::::::::
let _a, 10    ; lda #10
let P, _a     ; sta P
let _a, 15    ; lda #15
let Q, _a     ; sta Q
let _a, P     ; lda P
let _c, 0     ; clc
add _a, _a, Q ; adc Q
let R,_a      ; sta R
::::::::::::::::::::::::

For this example, following rules were used:

:::::::::::::::::::::::::::::::::::::::
rule let %A:byte, %B:byte = instr
  let _a,%B
  let %A,_a

rule add %A:byte, %B:byte, %C:byte = instr
  let _a,%B 
  let _c,0
  add _a,_a,%C
  let %A,_a

:::::::::::::::::::::::::::::::::::::::

============
Optimization
============

Compiler instructions (= processor instructions) are now optimized.

====
Emit
====

For every compiler instruction, appropriate rule generating source code is found.

::::::::::::::::::::::::
lda #10
sta P
lda #15
sta Q
lda P
clc
adc Q
sta R
::::::::::::::::::::::::

For this example, following rules were used:

::::::::::::::::::::::::
rule let _a,const %A:byte    = "   lda #%A"
rule let %A:byte,_a  = "   sta %A"
rule let _c, 0  = "   clc"
rule add _a,_a,%A:byte = "   adc %A"
::::::::::::::::::::::::

=============
Rule matching
=============

Rule is matched by instruction name.
All three rule parameters must then match.

::::::::::::::::::::::::
variable          If variable is specified, instruction must reference this variable in the argument.
                  It is used mainly for CPU registers, but other variables may be used too.
value             Concrete value (rule add x, x, 1 = "inx")
const %A:type     Constant. Range (or type) of the constant may be specified.              
%A:type           Value or variable of specified type
%A:type(%B)       Access to array element at index %B. Idx may be variable, value etc.
%A:type(%B,%C)    Access to 2d array
@%A               Reference to variable pointed to by %A (may include index)
%A$%B             Access to B-th byte of variable %A
%A-%B             Difference between %A and %B. Usable in indexes: %A(%B-const %C)
%A..%B            Range. Usefull with indexes %A(%B..%C)     
::::::::::::::::::::::::

Macro variable %Z has special meaning. It is used as local variable in macro evaluation.

Label specified in rule using "label" instruction is local (new temporary label is generated every time
macro is used.

- For commutative operations, if mathing rule for op A,B,C is not found, op A,C,B will be searched
- Constant is put on the right side of operation if possible
 