;********************************
;ATALAN C64 Platform definition
;********************************

;Define, which processor the platform uses.

use m6502

;prologue is emitted at the beginning of the generated assmbler file.
;Here you can define header of output binary and the starting address of an application.
;                                                                        800 801 802 803 804 805
;rule prologue = "   .segment ["]FS["]" "   .byt $00,$08" "   .segment ["]CODE["]" "_CODE_START:" "   .byt $00,$0b,$08,$40,$00,$9e,["]2062["],$00,$00,$00,$00"
rule prologue = ".export __LOADADDR__,__EXEHDR__" "" ".segment ["]LOADADDR["]" "__LOADADDR__=$0801" "   .byt <__LOADADDR__,>__LOADADDR__" "" ".segment ["]EXEHDR["]" "__EXEHDR__:" "   .byt $0b,$08,$40,$00,$9e,["]2060["],$00,$00" "" ".segment ["]CODE["]"

;epilogue is emitted at the end of code. 
rule epilogue = "   rts"

;code_end is instruction emitted after the end of code.
rule code_end = "_CODE_END:"     
rule line      = ";### %0(%1) %2"

;BIN_EXTENSION defines extension of the resulting binary file produced by compiler.
BIN_EXTENSION: "prg"

system.putchr_proc_adr@$c3:adr
system.buf@$7e8:adr ; for bcd translation


;VARHEAP defines memory area that can be used by Atalan to allocate variables.
;this area memory is used mainly by BASIC, so it is safe to use
type VARHEAP:3..143
 
type Device: enum
 keyboard : 0
 tape : 1
 rs232 : 2
 screen : 3
 prt1 : 4
 prt2 : 5
 prt3 : 6
 prt4 : 7
 fd8 : 8
 fd9 : 9
 fd10 : 10
 fd11 : 11
 fd12 : 12
 
; taki myk - dobre dla flag! 
;type dma'type:byte (narrow_playfield: 1, playfield: 2, wide_playfield: 3, missiles: 4, players: 8, hires_sprites: 16, dl: 32, off: 0)
 
type RowType:0..24
type ColType:0..39
type FileNameLen:0..15

in out screenMemory@1024:array(ColType,RowType) of byte 
in out keyboardBuffer@631:array(0..9) of byte
in out keyboardBufferSize@198:byte

in out secondaryFileAddress @$b9:byte

in out fileStatus @$90:byte

;********************************
; KERNAL FUNCTIONS
;********************************
KScnKey@$ff9f:proc                 -> matrix@$cb shift@$28d petsci@keyboardBuffer @cpu.a @cpu.x @cpu.y
KIecIn@$ffa5: proc                 -> b:byte@cpu.a
KChrIn@$ffcf: proc                 -> b:byte@cpu.a                                @cpu.a @cpu.y
KRdTim@$ffde: proc                 -> t1:byte@cpu.a t2:byte@cpu.x t3:byte@cpu.y   @cpu.a @cpu.x @cpu.y
KStop@$ffe1:  proc                 -> pressed@cpu.z pressed2@cpu.c                @cpu.a @cpu.x
KGetin@$ffe4: proc                 -> c:char@cpu.a                                @cpu.a
KGetCursor:   proc                 -> x:ColType@cpu.x y:RowType@cpu.y             @cpu.c
KReadSt@$ffb7:proc                 -> st@cpu.a                                    @cpu.a
KLoad@$ffd5:  proc lv:byte@cpu.a startAddr@(CPU.x,CPU.y):adr     -> state@cpu.c error@cpu.a lastByte@(cpu.x,cpu.y):adr  @cpu.a @cpu.x @cpu.y
; startAddr - zero page address of pointer
KSave@$ffd8:  proc startAddr:byte@cpu.a endAddr@(CPU.x,CPU.y):adr-> state@cpu.c error@cpu.a                             @cpu.a @cpu.x @cpu.y
;********************************
; KERNAL PROCEDURES
;********************************
KScInit@$ff81:proc                                                @cpu.a @cpu.x @cpu.y
KIOInit@$ff84:proc                                                @cpu.a @cpu.x
KRAMTas@$ff87:proc                                                @cpu.a @cpu.x @cpu.y
KLstnSA@$ff93:proc sa:byte@cpu.a                                  @cpu.a
KTalkSA@$ff96:proc sa:byte@cpu.a                                  @cpu.a
KIecOut@$ffa8:proc b:byte@cpu.a
KUntalk@$ffab:proc                                                @cpu.a
KUnlstn@$ffae:proc                                                @cpu.a
KListen@$ffb1:proc dev:Device@cpu.a                               @cpu.a
KTalk@$ffb4:  proc dev:Device@cpu.a                               @cpu.a
KSetLFS@$ffba:proc ln:byte@cpu.a dev:Device@cpu.x sa:byte@cpu.y
KSetNam@$ffbd:proc len:FileNameLen@cpu.a name@(CPU.x,CPU.y):adr
KOpen@$ffc0:  proc                                                @cpu.a @cpu.x @cpu.y
KClose@$ffc3: proc lfn:byte@cpu.a                                 @cpu.a @cpu.x @cpu.y
KChkIn@$ffc6: proc lfn:byte@cpu.x                                 @cpu.a @cpu.x
KChkOut@$ffc9:proc lfn:byte@cpu.x                                 @cpu.a @cpu.x
KClrChn@$ffcc:proc                                                @cpu.a @cpu.x
KChrOut@$ffd2:proc c:char@cpu.a
KSetTim@$ffbd:proc t1:byte@cpu.a t2:byte@cpu.x t3:byte@cpu.y
KClAll@$ffe7: proc                                                @cpu.a @cpu.x
KSetCursor:   proc x:ColType@CPU.x y:RowType@CPU.y                @cpu.c

;********************************
; VIC
;********************************
; w atari dziala tez bez (
type Color: enum (
 black
 white
 red
 cyan
 purple
 green
 blue
 yellow
 orange
 brown
 lightred
 garkgrey
 grey
 lightgreen
 lightblue
 lightgrey)

type Sprite:0..7

vicAdr@$d000:adr

vic:scope =
	in out sprite1X@$d000:array(0..15) of byte
	in out sprite1Y@$d001:array(0..15) of byte
	in out spritesHX@$d010:byte
	in out scrCtrlReg1@$d011:byte
	in out rasterLine@$d012:byte
	in out spriteOnOff@$d015:byte
	in spriteTall@$d017:byte
	in out irqStateReg@$d019:byte
	in borderColor @$d020:Color
	in backgroundColor @$d021:Color
	in out irqCtrlReg@$d01a:byte
	in spriteFat@$d01d:byte
	in spriteColor@$d027:array(Sprite) of Color

	setSpriteX:macro sprite:Sprite,x:int =
		if x > 255 then spritesHX$sprite = 1 else spritesXH$sprite = 0
		ind = sprite*2	  
		vic.sprite1X#ind = lo x
	
	setSpriteY:macro sprite:Sprite,y:int =
		ind = sprite*2
		vic.sprite1Y#ind = y
	
	spriteUp:macro sprite:Sprite =
		ind = sprite*2
		; qus dec = segfault
		;dec vic.sprite1Y#ind

	spriteDown:macro sprite:Sprite =
		ind = sprite*2
		inc vic.sprite1Y#ind

	spriteRight:macro sprite:Sprite =
		ind = sprite*2
		inc vic.sprite1X#ind

	enableSprite:macro sprite:Sprite,enabled:bool =
		vic.spriteOnOff$sprite = enabled

;********************************
; CIA 1
;********************************

cia1:scope =
        in out portA@$dc00:byte
        in out portB@$dc01:byte
        in out irqControlReg@$dc0d:byte

	  
;********************************
; I/O
;********************************
Joy1:scope =
	isUp:macro =
		if cia1.portB$0 = 1 then
	isDown:macro =
		cia1.portB$1 = 1
	isLeft:macro =
		cia1.portB$2 = 1
	isRight:macro =
		cia1.portB$3 = 1
	isFire:macro =
		cia1.portB$4 = 1

Joy2:scope =
	isUp:macro =
		cia1.portA$0 = 1
	isDown:macro =
		cia1.portA$1 = 1
	isLeft:macro =
		cia1.portA$2 = 1
	isRight:macro =
		cia1.portA$3 = 1
	isFire:macro =
		cia1.portA$4 = 1
		
Joystick: enum
 up : 1
 down : 2
 left : 4
 right : 8
 fire : 16
	
;********************************
; IRQ procedures
;********************************

;
; create atalan backend rules since we can't create assembler by macros
;

;in out irqTest @$314:adr

;enableRasterInts:proc line:int paddress:adr of IrqProc
;	cia1.irqControlReg = %01111111
	;  "    and vic.scrCtrlReg1"
	;  "    sta vic.scrCtrlReg1"
;	;vic.rasterLine = line
;	irqTest = paddress
;	vic.irqCtrlReg = 1

;enableNormalInts:proc x:adr of IrqProc = 
;  "    sei"
;       cpu.i = 1
;	cia1.irqControlReg = 255
;	vectors.irq = x
;       cpi.i = 0
;  "    cli"
  
; MACRO - finish interrupt routine by continue to KERNAL

kernal = $ea31

backToKernal:macro =
	goto kernal
	
;
; create raster procedure type
; 
;IrqProc:type = interrupt

;rule proc %A:IrqProc = "%A .proc"
  
;rule return %A:IrqProc = "   asl vic.irqStateReg" "   jmp $ea31"

;rule endproc %A:IrqProc = ".endp"
  
;enableOnRasterY: macro line:int x:adr of IrqProc = 
;	c64'enableRasterInts line x
	
;doOnRasterY:macro line:int x:adr of IrqProc =
;	vectors.irq = x
;	vic.rasterLine = line

;doOnIrq: macro x:adr of IrqProc =
;	enableNormalInts x
	
;
; create NMI procedure type
; 
;NmiProc:type = interrupt

;rule proc %A:NmiProc = "%A .proc" "   pha" "   txa"  "   pha" "   tya" "   pha"
  
;rule return %A:NmiProc = "   pla" "   tay" "   pla" "   tax" "   pla" "   rti"
  
;rule endproc %A:NmiProc = ".endp"

;********************************
; Various vectors
;********************************
;Vectors:scope =
;        in out irq@$314:adr of IrqProc
;        in out brk@$316:adr
;        in out nmi@$318:adr of NmiProc

